/**
 * Next.js Framework Adapter
 * Handles Next.js-specific configurations and integrations
 *
 * Part of the Content Management Package
 * Migrated from lib/adapters/nextjs-adapter.js
 */

import fs from 'fs';
import path from 'path';
import { FrameworkAdapter } from './base.js';

export class NextJSAdapter extends FrameworkAdapter {
  constructor(options = {}) {
    super(options);
    this.framework = 'nextjs';
  }

  /**
   * Get Next.js content directory
   */
  getContentDir() {
    // Next.js commonly uses content/ or data/ in the root
    return 'content';
  }

  /**
   * Get Next.js build directory
   */
  getBuildDir() {
    return '.next';
  }

  /**
   * Get Next.js configuration file
   */
  getConfigFile() {
    const configFiles = ['next.config.js', 'next.config.mjs', 'next.config.ts'];

    for (const configFile of configFiles) {
      if (fs.existsSync(path.join(this.projectRoot, configFile))) {
        return configFile;
      }
    }

    return 'next.config.js'; // Default
  }

  /**
   * Get Next.js-specific data directory structure
   */
  getDataDirStructure() {
    return {
      base: 'src/data', // or just 'data' for pages router
      content: 'content',
      public: 'public',
      assets: 'src/assets',
      components: 'src/components', // or 'components'
      pages: 'src/pages', // or 'pages' for pages router
      app: 'src/app', // for app router
      lib: 'src/lib',
      utils: 'src/utils',
      styles: 'src/styles',
    };
  }

  /**
   * Detect if using App Router vs Pages Router
   */
  getRouterType() {
    const appDir = path.join(this.projectRoot, 'src/app');
    const pagesDir = path.join(this.projectRoot, 'src/pages');
    const rootAppDir = path.join(this.projectRoot, 'app');
    const rootPagesDir = path.join(this.projectRoot, 'pages');

    if (fs.existsSync(appDir) || fs.existsSync(rootAppDir)) {
      return 'app';
    }

    if (fs.existsSync(pagesDir) || fs.existsSync(rootPagesDir)) {
      return 'pages';
    }

    return 'unknown';
  }

  /**
   * Validate Next.js project
   */
  validateProject() {
    const packageJsonPath = path.join(this.projectRoot, 'package.json');

    if (!fs.existsSync(packageJsonPath)) {
      return false;
    }

    try {
      const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'));
      const dependencies = {
        ...packageJson.dependencies,
        ...packageJson.devDependencies,
      };

      // Check for Next.js dependency
      return !!dependencies.next;
    } catch {
      return false;
    }
  }

  /**
   * Get Next.js-specific build commands
   */
  getBuildCommands() {
    return {
      dev: 'next dev',
      build: 'next build',
      preview: 'next start',
      start: 'next start',
      lint: 'next lint',
    };
  }

  /**
   * Transform content path for Next.js conventions
   */
  transformContentPath(sourcePath) {
    const routerType = this.getRouterType();

    // Adjust paths based on router type and project structure
    if (routerType === 'app') {
      // App router typically uses src/ structure
      return sourcePath;
    } else {
      // Pages router might not use src/
      // But keep src/data as it's common for data
      return sourcePath;
    }
  }

  /**
   * Get Next.js-specific file patterns
   */
  getFilePatterns() {
    return {
      content: ['**/*.mdx', '**/*.md', '**/*.json'],
      ignore: [
        'node_modules/**',
        '.git/**',
        '.next/**',
        'out/**',
        '.vercel/**',
        '.netlify/**',
      ],
      watch: ['src/**', 'pages/**', 'app/**', 'content/**', 'public/**'],
    };
  }

  /**
   * Setup Next.js-specific integration
   */
  async setupIntegration() {
    const routerType = this.getRouterType();

    // Check for MDX support in Next.js config
    const configFile = this.getConfigFile();
    const configPath = path.join(this.projectRoot, configFile);

    if (fs.existsSync(configPath)) {
      const configContent = fs.readFileSync(configPath, 'utf8');

      if (!configContent.includes('@next/mdx')) {
        console.warn('📝 Consider adding @next/mdx for MDX support in Next.js');

        console.warn('   npm install @next/mdx @mdx-js/react @mdx-js/loader');
      }
    }

    // Create lib utilities for content loading
    const libDir = path.join(this.projectRoot, 'src/lib');
    const contentLibPath = path.join(libDir, 'content.js');

    if (!fs.existsSync(contentLibPath)) {
      if (!fs.existsSync(libDir)) {
        fs.mkdirSync(libDir, { recursive: true });
      }

      const contentLib = `// Content utilities for Next.js applications
// Auto-generated by content management system

import fs from 'fs';
import path from 'path';
import matter from 'gray-matter';

const contentDirectory = path.join(process.cwd(), 'src/data');

/**
 * Get content data by path
 * @param {string} filePath - Path to content file
 * @returns {any} Parsed content data
 */
export function getContentData(filePath) {
  const fullPath = path.join(contentDirectory, filePath);

  if (!fs.existsSync(fullPath)) {
    return null;
  }

  const fileExtension = path.extname(fullPath);

  if (fileExtension === '.json') {
    const jsonContent = fs.readFileSync(fullPath, 'utf8');
    return JSON.parse(jsonContent);
  }

  if (fileExtension === '.md' || fileExtension === '.mdx') {
    const markdownContent = fs.readFileSync(fullPath, 'utf8');
    const { data, content } = matter(markdownContent);
    return { frontmatter: data, content };
  }

  return null;
}

/**
 * Get all content files in a directory
 * @param {string} directory - Directory path relative to content directory
 * @returns {string[]} Array of file paths
 */
export function getContentFiles(directory) {
  const fullPath = path.join(contentDirectory, directory);

  if (!fs.existsSync(fullPath)) {
    return [];
  }

  const files = fs.readdirSync(fullPath, { recursive: true });
  return files
    .filter(file => {
      const ext = path.extname(file);
      return ['.md', '.mdx', '.json'].includes(ext);
    })
    .map(file => path.join(directory, file));
}

/**
 * Get static props for a content page (Next.js helper)
 * @param {string} filePath - Path to content file
 * @returns {object} Static props object
 */
export function getContentStaticProps(filePath) {
  const contentData = getContentData(filePath);

  return {
    props: {
      content: contentData
    }
  };
}

/**
 * Get static paths for dynamic content routes
 * @param {string} directory - Content directory
 * @param {string} paramName - Dynamic route parameter name
 * @returns {object} Static paths object
 */
export function getContentStaticPaths(directory, paramName = 'slug') {
  const files = getContentFiles(directory);

  const paths = files.map(file => {
    const slug = path.basename(file, path.extname(file));
    return {
      params: {
        [paramName]: slug
      }
    };
  });

  return {
    paths,
    fallback: false
  };
}
`;

      fs.writeFileSync(contentLibPath, contentLib);
    }

    // Create middleware for content handling if using app router
    if (routerType === 'app') {
      const middlewarePath = path.join(this.projectRoot, 'middleware.js');

      if (!fs.existsSync(middlewarePath)) {
        // Middleware template available but not auto-created
        // Users can manually create if needed

        console.log(
          '💡 Consider creating middleware.js for content routing in App Router'
        );
      }
    }
  }

  /**
   * Get Next.js-specific package scripts
   */
  getPackageScripts() {
    return {
      ...super.getPackageScripts(),
      'dev:content':
        'node git-files-sync/content-fetcher.js --watch & next dev',
      'build:content':
        'node git-files-sync/content-fetcher.js --force && next build',
      start: 'next start',
      lint: 'next lint',
    };
  }

  /**
   * Get Next.js-specific environment variables
   */
  getEnvironmentConfig() {
    return {
      ...super.getEnvironmentConfig(),
      nextOutput: 'NEXT_OUTPUT', // 'standalone' | 'export'
      nextImageDomains: 'NEXT_IMAGE_DOMAINS',
    };
  }

  /**
   * Get Next.js-specific gitignore patterns
   */
  getGitignorePatterns() {
    return [
      ...super.getGitignorePatterns(),
      '/.next/',
      '/out/',
      '/.vercel/',
      '/.netlify/',
      '.env.local',
      '.env.production.local',
      '.env.development.local',
    ];
  }
}
